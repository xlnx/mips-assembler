"label"_t = "[A-Za-z_]\\w*"_rw
	>> lexer_reflect<ast_type>([](const string &src)->value_type{
		return unsigned(stoi(src.substr(1)));
	}),

"add"_t = "add"_riw,
"sub"_t = "sub"_riw,
"and"_t = "and"_riw,
"or"_t = "or"_riw,
"addi"_t = "addi"_riw,
"ori"_t = "ori"_riw,
"sll"_t = "sll"_riw,
"srl"_t = "srl"_riw,
"lw"_t = "lw"_riw,
"sw"_t = "sw"_riw,
"lui"_t = "lui"_riw,
"slt"_t = "slt"_riw,
"slti"_t = "slti"_riw,
"beq"_t = "beq"_riw,
"bne"_t = "bne"_riw,
"j"_t = "j"_riw,
"jal"_t = "jal"_riw,
"jr"_t = "jr"_riw,

"reg"_t = "\\$([0-9]|[1-2][0-9]|31|30)"_rw
	>> lexer_reflect<ast_type>([](const string &src)->value_type{
		return unsigned(stoi(src.substr(1)));
	}),

"imm"_t = "(?:0[Xx][0-9A-Fa-f]+|0[0-7]*|[1-9][0-9]*)"_rw
	>> lexer_reflect<ast_type>([](const string &src)->value_type{
		if (src[0] == '0')
		{
			if (src.length() > 1 && (src[1] == 'X' || src[1] == 'x'))
			{
				istringstream is(src.substr(2));
				int x; is >> hex >> x; return x;
			}
			else
			{
				istringstream is(src.substr(1));
				int x; is >> oct >> x; return x;
			}
		}
		else
		{
			istringstream is(src);
			int x; is >> dec >> x; return x;
		}
	}),

":"_t = ":"_r,
","_t = ","_r